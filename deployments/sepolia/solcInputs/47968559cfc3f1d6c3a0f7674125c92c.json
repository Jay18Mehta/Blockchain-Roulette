{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig() external view returns (uint16, uint32, bytes32[] memory);\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(\n    uint64 subId\n  ) external view returns (uint96 balance, uint64 reqCount, address owner, address[] memory consumers);\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint64 subId) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "contracts/Roulette.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol\";\n\nerror roulette__BalanceOutsideBound();\nerror roulette__NotEnoughMoneyToPlay();\nerror roulette__WaitForRouletteToCompleteProcess();\nerror roulette__TransferFailed();\nerror roulette__NotOwner();\nerror roulette__notEnoughMoneyInContract();\n\ncontract Roulette is VRFConsumerBaseV2 {\n\n    /**Enum */\n    enum Roulette_State{\n        play,wait\n    }\n\n    modifier onlyOwner {\n        if(msg.sender != i_owner){\n            revert roulette__NotOwner();\n        }\n        _;\n    }\n\n    //chainlink vrf variables\n    VRFCoordinatorV2Interface public immutable i_vrfCoordinator;\n    uint64 private immutable i_subscriptionId;\n    bytes32 private immutable i_gasLane;\n    uint32 private immutable i_callbackGasLimit;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    uint32 private constant NUM_WORDS = 1;\n\n    // VRF helpers\n    mapping(uint256=>address) public s_requestIdToSender;\n    \n    //contract variabless\n    address private immutable i_owner;\n    int256 private s_contractFund;\n\n    //user variables\n    struct User {\n        int256 ethAmount;\n        uint256 rouletteAnswer;\n        uint256[] straightUpBets;\n        string[] outsideBets;\n        Roulette_State roulette_State;\n    }\n    mapping(address => User) private s_userMapping;\n    uint256 private immutable i_minEthBalance; // 0.01 \n    uint256 private immutable i_maxEthBalance; //0.1\n\n    //roulette variables\n    uint16 private constant TOTAL_POSSIBLE_OUTPUTS = 38;\n    uint256 private immutable i_straightUpBetsValue;\n    uint256 private immutable i_outsideBetsValue;\n    bytes32 private constant ONE_TO_TWELVE = keccak256(abi.encodePacked(\"ONE_TO_TWELVE\"));\n    bytes32 private constant THIRTEEN_TO_TWENTYFOUR = keccak256(abi.encodePacked(\"THIRTEEN_TO_TWENTYFOUR\"));\n    bytes32 private constant TWENTYFIVE_TO_THIRTYSIX = keccak256(abi.encodePacked(\"TWENTYFIVE_TO_THIRTYSIX\"));\n    bytes32 private constant ONE_TO_EIGHTEEN = keccak256(abi.encodePacked(\"ONE_TO_EIGHTEEN\"));\n    bytes32 private constant NINETEEN_TO_THIRTYSIX = keccak256(abi.encodePacked(\"NINETEEN_TO_THIRTYSIX\"));\n    bytes32 private constant FIRST_COLOUMN = keccak256(abi.encodePacked(\"FIRST_COLOUMN\"));\n    bytes32 private constant SECOND_COLOUMN = keccak256(abi.encodePacked(\"SECOND_COLOUMN\"));\n    bytes32 private constant THIRD_COLOUMN = keccak256(abi.encodePacked(\"THIRD_COLOUMN\"));\n    bytes32 private constant ODD = keccak256(abi.encodePacked(\"ODD\"));\n    bytes32 private constant EVEN = keccak256(abi.encodePacked(\"EVEN\"));\n    bytes32 private constant RED = keccak256(abi.encodePacked(\"RED\"));\n    bytes32 private constant BLACK = keccak256(abi.encodePacked(\"BLACK\"));\n    bytes32[36] private s_numberColour = [RED,BLACK,RED,BLACK,RED,BLACK,RED,BLACK,RED,BLACK,BLACK,RED,BLACK,RED,BLACK,RED,BLACK,RED,RED,BLACK,RED,BLACK,RED,BLACK,RED,BLACK,RED,BLACK,BLACK,RED,BLACK,RED,BLACK,RED,BLACK,RED];\n\n    //events\n    event winAmountEvent(int256 indexed winAmount);\n    event numberPicked(uint256 indexed number);\n    event userRequestId(uint256 indexed requestId);\n\n    constructor(uint256 _minEthBalance,uint256 _maxEthBalance,address _vrfCoordinator,uint64 subscriptionId,bytes32 gasLane,uint32 callbackGasLimit,uint256 straightUpBetsValue,uint256 outsideBetsValue) VRFConsumerBaseV2(_vrfCoordinator){\n        i_minEthBalance = _minEthBalance;\n        i_maxEthBalance = _maxEthBalance;\n        i_vrfCoordinator=VRFCoordinatorV2Interface(_vrfCoordinator);\n        i_gasLane = gasLane;\n        i_subscriptionId = subscriptionId;\n        i_callbackGasLimit = callbackGasLimit;\n        i_straightUpBetsValue = straightUpBetsValue;\n        i_outsideBetsValue = outsideBetsValue;\n        i_owner=msg.sender;\n    }\n\n    function fundContract() public payable onlyOwner {\n        s_contractFund+=int256(msg.value);\n    }    \n\n    function addBalance() public payable{\n        if(!(i_minEthBalance<=msg.value+uint256(s_userMapping[msg.sender].ethAmount) && msg.value+uint256(s_userMapping[msg.sender].ethAmount)<=i_maxEthBalance)){\n            revert roulette__BalanceOutsideBound();\n        }\n        s_userMapping[msg.sender].ethAmount +=int256(msg.value);\n    }\n\n    function requestRandomWords(uint256[] memory straightUpBets,string[] memory outsideBets) public returns(uint256 requestId){\n        User memory user = s_userMapping[msg.sender];\n        if(user.roulette_State == Roulette_State.wait){\n            revert roulette__WaitForRouletteToCompleteProcess();\n        }\n        int256 betAmount = int256(straightUpBets.length*i_straightUpBetsValue+outsideBets.length*i_outsideBetsValue);\n        if(user.ethAmount < betAmount){\n            revert roulette__NotEnoughMoneyToPlay();\n        }\n        if(s_contractFund <=0){\n            revert roulette__notEnoughMoneyInContract();\n        }\n        user.roulette_State = Roulette_State.wait;\n        user.straightUpBets = straightUpBets;\n        user.outsideBets = outsideBets;\n        requestId=i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            NUM_WORDS\n        );\n        s_userMapping[msg.sender] = user;\n\n        s_requestIdToSender[requestId] = msg.sender;\n\n        emit userRequestId(requestId);\n    }\n\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override{\n        address userAddress = s_requestIdToSender[requestId];\n        User memory user = s_userMapping[userAddress];\n        uint256[] memory straightUpBets = user.straightUpBets;\n        string[] memory outsideBets = user.outsideBets;\n\n        uint256 rouletteAnswer = randomWords[0]%TOTAL_POSSIBLE_OUTPUTS;\n        \n        int256 winAmount = calculateWinAmount(rouletteAnswer,straightUpBets,outsideBets);\n\n        user.rouletteAnswer = rouletteAnswer;\n        user.ethAmount+=winAmount;\n        user.roulette_State = Roulette_State.play;\n        s_userMapping[userAddress] = user;\n        s_contractFund -= winAmount;\n\n        emit numberPicked(rouletteAnswer);\n    }\n\n    function calculateWinAmount(uint256 rouletteAnswer,uint256[] memory straightUpBets,string[] memory outsideBets)public returns(int256){\n        int256 winAmount = -1*int256(straightUpBets.length*i_straightUpBetsValue+outsideBets.length*i_outsideBetsValue);\n\n        for(uint256 i = 0;i<straightUpBets.length;i++){  //considering 37 = 00\n            if(straightUpBets[i] == rouletteAnswer){\n                winAmount+=int256(36*i_straightUpBetsValue);\n            }\n        }\n\n        if(!(rouletteAnswer==0 || rouletteAnswer==37)){\n            for(uint256 i= 0;i<outsideBets.length;i++){\n                bytes32 bet = keccak256(abi.encodePacked(outsideBets[i]));\n                if(bet == ONE_TO_TWELVE && rouletteAnswer<=12){\n                    winAmount+=int256(3*i_outsideBetsValue);\n                }\n                else if(bet == THIRTEEN_TO_TWENTYFOUR && rouletteAnswer>=13 && rouletteAnswer<=24){\n                    winAmount+=int256(3*i_outsideBetsValue);\n                }\n                else if(bet == TWENTYFIVE_TO_THIRTYSIX && rouletteAnswer>=25){\n                    winAmount+=int256(3*i_outsideBetsValue);\n                }\n                else if(bet == ONE_TO_EIGHTEEN && rouletteAnswer<=18){\n                    winAmount+=int256(2*i_outsideBetsValue);\n                }\n                else if(bet == NINETEEN_TO_THIRTYSIX && rouletteAnswer>=19){\n                    winAmount+=int256(2*i_outsideBetsValue);\n                }\n                else if(bet == FIRST_COLOUMN && rouletteAnswer%3==1){\n                    winAmount+=int256(3*i_outsideBetsValue);\n                }\n                else if(bet == SECOND_COLOUMN && rouletteAnswer%3==2){\n                    winAmount+=int256(3*i_outsideBetsValue);\n                }\n                else if(bet == THIRD_COLOUMN && rouletteAnswer%3==0){\n                    winAmount+=int256(3*i_outsideBetsValue);\n                }\n                else if(bet == ODD && rouletteAnswer%2==1){\n                    winAmount+=int256(2*i_outsideBetsValue);\n                }\n                else if(bet == EVEN && rouletteAnswer%2==0){\n                    winAmount+=int256(2*i_outsideBetsValue);\n                } \n                else if(bet == RED && bet == s_numberColour[rouletteAnswer-1]){\n                    winAmount+=int256(2*i_outsideBetsValue);\n                }\n                else if(bet == BLACK && bet == s_numberColour[rouletteAnswer-1]){\n                    winAmount+=int256(2*i_outsideBetsValue);\n                } \n                else if(bet != ODD && bet!=EVEN && bet != RED && bet!=BLACK && bet!=ONE_TO_TWELVE && bet!=THIRTEEN_TO_TWENTYFOUR && bet!=TWENTYFIVE_TO_THIRTYSIX && bet!=ONE_TO_EIGHTEEN && bet!=NINETEEN_TO_THIRTYSIX && bet!=FIRST_COLOUMN && bet!=SECOND_COLOUMN && bet!=THIRD_COLOUMN){  //error hanndling\n                    winAmount+=int256(i_outsideBetsValue);\n                }\n            }\n        }\n        emit winAmountEvent(winAmount);\n        return winAmount;\n    }\n\n    function withdrawBalance() public {\n        User memory user = s_userMapping[msg.sender];\n        if(0> s_contractFund){\n            revert roulette__notEnoughMoneyInContract();\n        }\n        (bool callSuccess, ) = /*(user.payableAddress)*/payable(msg.sender).call{value: uint256(user.ethAmount)}(\"\");\n        if (!callSuccess) {\n            revert roulette__TransferFailed();\n        }\n        s_userMapping[msg.sender].ethAmount -= user.ethAmount;\n    }\n\n    function withdrawContractFund(uint256 funds) public onlyOwner {\n        if(s_contractFund<int256(funds)){\n            revert roulette__notEnoughMoneyInContract();\n        }\n        (bool callSuccess, ) = payable(i_owner).call{value: funds}(\"\");\n        if (!callSuccess) {\n            revert roulette__TransferFailed();\n        }\n        s_contractFund-=int256(funds);\n    }\n\n    function getGasLane() public view returns(bytes32){\n        return i_gasLane;\n    }\n    function getCallBackGasLimit() public view returns(uint32){\n        return i_callbackGasLimit;\n    }\n    function getNumWords() public pure returns(uint32){\n        return NUM_WORDS;\n    }\n     function getMinEthBalance() public view returns(uint256){\n        return i_minEthBalance;\n    }\n    function getMaxEthBalance() public view returns(uint256){\n        return i_maxEthBalance;\n    }\n    function getContractOwner() public view returns(address){\n        return i_owner;\n    }\n    function getContractFund() public view returns(int256){\n        return s_contractFund;\n    }\n    function getUserMapping(address user) public view returns(User memory){\n        return s_userMapping[user];\n    }\n    function getStraightUpBetsValue() public view returns(uint256){\n        return i_straightUpBetsValue;\n    }\n    function getOutsideBetsValue() public view returns(uint256){\n        return i_outsideBetsValue;\n    }\n\n    fallback() external payable {\n        if(msg.sender != i_owner){\n            addBalance();\n        }\n    }\n\n    receive() external payable {\n        if(msg.sender != i_owner){\n            addBalance();\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}